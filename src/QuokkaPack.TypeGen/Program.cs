using System;
using System.Collections.Generic;
using System.CommandLine;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using QuokkaPack.Shared.Models;
using QuokkaPack.Shared.DTOs.Trip;
using QuokkaPack.Shared.DTOs.CategoryDTOs;
using QuokkaPack.Shared.DTOs.ItemDTOs;
using QuokkaPack.Shared.DTOs.TripItem;
using QuokkaPack.Shared.DTOs.TripCatalogItem;

namespace QuokkaPack.TypeGen;

class Program
{
    static async Task<int> Main(string[] args)
    {
        var outputOption = new Option<string>(
            name: "--output",
            description: "Output file path for generated TypeScript types")
        {
            IsRequired = true
        };

        var rootCommand = new RootCommand("Generate TypeScript types from C# models")
        {
            outputOption
        };

        rootCommand.SetHandler(GenerateTypes, outputOption);

        return await rootCommand.InvokeAsync(args);
    }

    static void GenerateTypes(string outputPath)
    {
        var sb = new StringBuilder();
        
        // Header comment
        sb.AppendLine("// Auto-generated TypeScript types from C# models");
        sb.AppendLine("// Do not edit this file manually - it will be overwritten");
        sb.AppendLine();

        // Generate types for all relevant models and DTOs
        var typesToGenerate = new[]
        {
            // Models
            typeof(Trip),
            typeof(Category),
            typeof(Item),
            typeof(TripItem),
            typeof(MasterUser),
            typeof(AppUserLogin),
            
            // DTOs
            typeof(TripSummaryReadDto),
            typeof(TripDetailsReadDto),
            typeof(TripEditDto),
            typeof(TripCreateDto),
            typeof(CategoryReadDto),
            typeof(CategoryReadDtoSimple),
            typeof(CategoryCreateDto),
            typeof(CategoryEditDto),
            typeof(ItemReadDto),
            typeof(ItemCreateDto),
            typeof(ItemEditDto),
            typeof(TripItemReadDto),
            typeof(TripItemCreateDto),
            typeof(TripItemEditDto),
            typeof(TripCatalogItemReadDto)
        };

        // Generate enums first
        var enumsToGenerate = new[]
        {
            typeof(QuokkaPack.Shared.DTOs.TripCatalogItem.ItemTripStatus)
        };

        foreach (var enumType in enumsToGenerate)
        {
            GenerateTypeScriptEnum(sb, enumType);
            sb.AppendLine();
        }

        foreach (var type in typesToGenerate)
        {
            GenerateTypeScriptInterface(sb, type);
            sb.AppendLine();
        }

        // Ensure output directory exists
        var outputDir = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
        {
            Directory.CreateDirectory(outputDir);
        }

        File.WriteAllText(outputPath, sb.ToString());
        Console.WriteLine($"Generated TypeScript types at: {outputPath}");
    }

    static void GenerateTypeScriptInterface(StringBuilder sb, Type type)
    {
        sb.AppendLine($"export interface {type.Name} {{");

        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        
        foreach (var prop in properties)
        {
            var tsType = GetTypeScriptType(prop.PropertyType);
            var isOptional = IsNullable(prop.PropertyType) ? "?" : "";
            sb.AppendLine($"  {ToCamelCase(prop.Name)}{isOptional}: {tsType};");
        }

        sb.AppendLine("}");
    }

    static void GenerateTypeScriptEnum(StringBuilder sb, Type enumType)
    {
        sb.AppendLine($"export enum {enumType.Name} {{");

        var enumValues = Enum.GetValues(enumType);
        var enumNames = Enum.GetNames(enumType);

        for (int i = 0; i < enumNames.Length; i++)
        {
            var enumValue = Convert.ToInt32(enumValues.GetValue(i));
            sb.AppendLine($"  {enumNames[i]} = {enumValue},");
        }

        sb.AppendLine("}");
    }

    static string GetTypeScriptType(Type type)
    {
        // Handle nullable types
        var underlyingType = Nullable.GetUnderlyingType(type) ?? type;

        // Handle arrays and collections
        if (type.IsArray)
        {
            var elementType = type.GetElementType()!;
            return $"{GetTypeScriptType(elementType)}[]";
        }

        if (type.IsGenericType)
        {
            var genericTypeDef = type.GetGenericTypeDefinition();
            if (genericTypeDef == typeof(List<>) || genericTypeDef == typeof(ICollection<>) || genericTypeDef == typeof(IEnumerable<>))
            {
                var elementType = type.GetGenericArguments()[0];
                return $"{GetTypeScriptType(elementType)}[]";
            }
        }

        // Handle enums
        if (underlyingType.IsEnum)
        {
            return underlyingType.Name;
        }

        // Map C# types to TypeScript types
        return underlyingType.Name switch
        {
            "String" => "string",
            "Int32" or "Int64" or "Double" or "Decimal" or "Float" or "Single" => "number",
            "Boolean" => "boolean",
            "DateTime" or "DateTimeOffset" or "DateOnly" => "string", // API returns dates as strings
            "Guid" => "string",
            _ => underlyingType.Name // For custom types, use the class name
        };
    }

    static bool IsNullable(Type type)
    {
        return !type.IsValueType || Nullable.GetUnderlyingType(type) != null;
    }

    static string ToCamelCase(string input)
    {
        if (string.IsNullOrEmpty(input) || char.IsLower(input[0]))
            return input;

        return char.ToLower(input[0]) + input[1..];
    }
}