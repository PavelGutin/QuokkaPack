@page "/login"

@using System.ComponentModel.DataAnnotations
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Authorization
@using QuokkaPack.Blazor.Providers

@inject IHttpClientFactory HttpClientFactory
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager Nav

<h3>Login</h3>

<EditForm Model="model" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    @if (!string.IsNullOrEmpty(error))
    {
        <div class="alert alert-danger">@error</div>
    }

    <div class="mb-3">
        <label>Email</label>
        <InputText class="form-control" @bind-Value="model.Email" />
        <ValidationMessage For="() => model.Email" />
    </div>

    <div class="mb-3">
        <label>Password</label>
        <InputText class="form-control" @bind-Value="model.Password" type="password" />
        <ValidationMessage For="() => model.Password" />
    </div>

    <div class="form-check mb-3">
        <InputCheckbox class="form-check-input" @bind-Value="model.RememberMe" />
        <label class="form-check-label">Remember me</label>
    </div>

    <button class="btn btn-primary" type="submit" disabled="@isBusy">
        @(isBusy ? "Signing in..." : "Sign in")
    </button>
</EditForm>

@code {
    // Accept ?returnUrl=/some/path from the query string
    [Parameter, SupplyParameterFromQuery]
    public string? returnUrl { get; set; }

    private LoginModel model = new();
    private bool isBusy;
    private string? error;

    protected override void OnParametersSet()
    {
        // Keep any existing model.ReturnUrl if user navigated here intentionally,
        // otherwise prefer the query-string returnUrl.
        model.ReturnUrl ??= returnUrl;
    }

    private async Task HandleValidSubmit()
    {
        isBusy = true;
        error = null;

        try
        {
            var api = HttpClientFactory.CreateClient("Api");

            // Adjust endpoint if yours differs (e.g., "api/Auth/login" or "api/Account/login")
            var resp = await api.PostAsJsonAsync("api/Auth/login", new
            {
                email = model.Email,
                password = model.Password,
                rememberMe = model.RememberMe
            });

            if (!resp.IsSuccessStatusCode)
            {
                var details = await resp.Content.ReadAsStringAsync();
                error = $"Login failed: {(int)resp.StatusCode} {resp.ReasonPhrase}";
                return;
            }

            var result = await resp.Content.ReadFromJsonAsync<LoginResponse>();

            if (string.IsNullOrWhiteSpace(result?.Token))
            {
                error = "Login succeeded but no token was returned.";
                return;
            }

            // Store token and update auth state
            if (AuthStateProvider is JwtAuthStateProvider jwt)
                await jwt.SetTokenAsync(result.Token);

            // Navigate to returnUrl (if provided) or home
            var target = string.IsNullOrWhiteSpace(model.ReturnUrl) ? "/" : model.ReturnUrl!;
            Nav.NavigateTo(target, forceLoad: true);
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
        finally
        {
            isBusy = false;
        }
    }

    private sealed class LoginModel
    {
        [Required, EmailAddress]
        public string Email { get; set; } = "";

        [Required]
        public string Password { get; set; } = "";

        public bool RememberMe { get; set; }

        public string? ReturnUrl { get; set; }
    }

    private sealed class LoginResponse
    {
        // Match your API’s JSON property names exactly
        public string? Token { get; set; }
        public DateTime? ExpiresAt { get; set; }
    }
}
