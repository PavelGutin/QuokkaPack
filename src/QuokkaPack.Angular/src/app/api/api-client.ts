//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @return OK
     */
    login(body: LoginModel): Observable<void>;
    /**
     * @return OK
     */
    register(body: RegisterRequest): Observable<void>;
    /**
     * @param includeArchived (optional) 
     * @return OK
     */
    categoriesAll(includeArchived: boolean | undefined): Observable<CategoryReadDto[]>;
    /**
     * @return OK
     */
    categoriesPOST(body: CategoryCreateDto): Observable<CategoryReadDto>;
    /**
     * @return OK
     */
    categoriesGET(id: number): Observable<CategoryReadDto>;
    /**
     * @return OK
     */
    categoriesPUT(id: number, body: CategoryEditDto): Observable<void>;
    /**
     * @return OK
     */
    categoriesDELETE(id: number): Observable<void>;
    /**
     * @return OK
     */
    archive(id: number): Observable<void>;
    /**
     * @return OK
     */
    restore(id: number): Observable<void>;
    /**
     * @return OK
     */
    health(): Observable<void>;
    /**
     * @return OK
     */
    detailed(): Observable<void>;
    /**
     * @param includeArchived (optional) 
     * @return OK
     */
    itemsAll(includeArchived: boolean | undefined): Observable<ItemReadDto[]>;
    /**
     * @return OK
     */
    itemsPOST(body: ItemCreateDto): Observable<ItemReadDto>;
    /**
     * @return OK
     */
    itemsGET(id: number): Observable<ItemReadDto>;
    /**
     * @return OK
     */
    itemsPUT(id: number, body: ItemEditDto): Observable<void>;
    /**
     * @return OK
     */
    itemsDELETE(id: number): Observable<void>;
    /**
     * @return OK
     */
    archive2(id: number): Observable<void>;
    /**
     * @return OK
     */
    restore2(id: number): Observable<void>;
    /**
     * @return OK
     */
    categoriesPOST2(tripId: number, body: number): Observable<void>;
    /**
     * @return OK
     */
    batchPOST(tripId: number, body: number[]): Observable<void>;
    /**
     * @return OK
     */
    batchDELETE(tripId: number, body: number[]): Observable<void>;
    /**
     * @return OK
     */
    categoriesDELETE2(tripId: number, categoryId: number): Observable<void>;
    /**
     * @return OK
     */
    reset(tripId: number, categoryId: number): Observable<void>;
    /**
     * @return OK
     */
    tripItemsAll(tripId: number): Observable<TripItemReadDto[]>;
    /**
     * @return OK
     */
    tripItemsPOST(tripId: number, body: TripItemCreateDto): Observable<void>;
    /**
     * @return OK
     */
    tripItemsPUT(tripId: number, tripItemId: number, body: TripItemEditDto): Observable<void>;
    /**
     * @return OK
     */
    tripItemsDELETE(tripId: number, tripItemId: number): Observable<void>;
    /**
     * @return OK
     */
    batchPUT(tripId: number, body: TripItemEditDto[]): Observable<void>;
    /**
     * @return OK
     */
    tripsAll(): Observable<TripSummaryReadDto[]>;
    /**
     * @return OK
     */
    tripsPOST(body: TripCreateDto): Observable<TripSummaryReadDto>;
    /**
     * @return OK
     */
    tripsGET(id: number): Observable<TripDetailsReadDto>;
    /**
     * @return OK
     */
    tripsPUT(id: number, body: TripEditDto): Observable<void>;
    /**
     * @return OK
     */
    tripsDELETE(id: number): Observable<void>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:5000/";
    }

    /**
     * @return OK
     */
    login(body: LoginModel): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param includeArchived (optional) 
     * @return OK
     */
    categoriesAll(includeArchived: boolean | undefined): Observable<CategoryReadDto[]> {
        let url_ = this.baseUrl + "/api/Categories?";
        if (includeArchived === null)
            throw new globalThis.Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryReadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryReadDto[]>;
        }));
    }

    protected processCategoriesAll(response: HttpResponseBase): Observable<CategoryReadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryReadDto.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf([] as CategoryReadDto[]);
    }

    /**
     * @return OK
     */
    categoriesPOST(body: CategoryCreateDto): Observable<CategoryReadDto> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryReadDto>;
        }));
    }

    protected processCategoriesPOST(response: HttpResponseBase): Observable<CategoryReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CategoryReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryReadDto>(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET(id: number): Observable<CategoryReadDto> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryReadDto>;
        }));
    }

    protected processCategoriesGET(response: HttpResponseBase): Observable<CategoryReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CategoryReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryReadDto>(null as any);
    }

    /**
     * @return OK
     */
    categoriesPUT(id: number, body: CategoryEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    archive(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}/archive";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    restore(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}/restore";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    health(): Observable<void> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHealth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    detailed(): Observable<void> {
        let url_ = this.baseUrl + "/api/Health/detailed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param includeArchived (optional) 
     * @return OK
     */
    itemsAll(includeArchived: boolean | undefined): Observable<ItemReadDto[]> {
        let url_ = this.baseUrl + "/api/Items?";
        if (includeArchived === null)
            throw new globalThis.Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemReadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemReadDto[]>;
        }));
    }

    protected processItemsAll(response: HttpResponseBase): Observable<ItemReadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemReadDto.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf([] as ItemReadDto[]);
    }

    /**
     * @return OK
     */
    itemsPOST(body: ItemCreateDto): Observable<ItemReadDto> {
        let url_ = this.baseUrl + "/api/Items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemReadDto>;
        }));
    }

    protected processItemsPOST(response: HttpResponseBase): Observable<ItemReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ItemReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemReadDto>(null as any);
    }

    /**
     * @return OK
     */
    itemsGET(id: number): Observable<ItemReadDto> {
        let url_ = this.baseUrl + "/api/Items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemReadDto>;
        }));
    }

    protected processItemsGET(response: HttpResponseBase): Observable<ItemReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ItemReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemReadDto>(null as any);
    }

    /**
     * @return OK
     */
    itemsPUT(id: number, body: ItemEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processItemsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    itemsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processItemsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    archive2(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Items/{id}/archive";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchive2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processArchive2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    restore2(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Items/{id}/restore";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestore2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesPOST2(tripId: number, body: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/Categories";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesPOST2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    batchPOST(tripId: number, body: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/Categories/batch";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    batchDELETE(tripId: number, body: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/Categories/batch";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesDELETE2(tripId: number, categoryId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/Categories/{categoryId}";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesDELETE2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    reset(tripId: number, categoryId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/Categories/{categoryId}/reset";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    tripItemsAll(tripId: number): Observable<TripItemReadDto[]> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/TripItems";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripItemsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripItemsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TripItemReadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TripItemReadDto[]>;
        }));
    }

    protected processTripItemsAll(response: HttpResponseBase): Observable<TripItemReadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TripItemReadDto.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf([] as TripItemReadDto[]);
    }

    /**
     * @return OK
     */
    tripItemsPOST(tripId: number, body: TripItemCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/TripItems";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripItemsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripItemsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTripItemsPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    tripItemsPUT(tripId: number, tripItemId: number, body: TripItemEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/TripItems/{tripItemId}";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        if (tripItemId === undefined || tripItemId === null)
            throw new globalThis.Error("The parameter 'tripItemId' must be defined.");
        url_ = url_.replace("{tripItemId}", encodeURIComponent("" + tripItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripItemsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripItemsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTripItemsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    tripItemsDELETE(tripId: number, tripItemId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/TripItems/{tripItemId}";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        if (tripItemId === undefined || tripItemId === null)
            throw new globalThis.Error("The parameter 'tripItemId' must be defined.");
        url_ = url_.replace("{tripItemId}", encodeURIComponent("" + tripItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripItemsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripItemsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTripItemsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    batchPUT(tripId: number, body: TripItemEditDto[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{tripId}/TripItems/batch";
        if (tripId === undefined || tripId === null)
            throw new globalThis.Error("The parameter 'tripId' must be defined.");
        url_ = url_.replace("{tripId}", encodeURIComponent("" + tripId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    tripsAll(): Observable<TripSummaryReadDto[]> {
        let url_ = this.baseUrl + "/api/Trips";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TripSummaryReadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TripSummaryReadDto[]>;
        }));
    }

    protected processTripsAll(response: HttpResponseBase): Observable<TripSummaryReadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TripSummaryReadDto.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf([] as TripSummaryReadDto[]);
    }

    /**
     * @return OK
     */
    tripsPOST(body: TripCreateDto): Observable<TripSummaryReadDto> {
        let url_ = this.baseUrl + "/api/Trips";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TripSummaryReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TripSummaryReadDto>;
        }));
    }

    protected processTripsPOST(response: HttpResponseBase): Observable<TripSummaryReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = TripSummaryReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TripSummaryReadDto>(null as any);
    }

    /**
     * @return OK
     */
    tripsGET(id: number): Observable<TripDetailsReadDto> {
        let url_ = this.baseUrl + "/api/Trips/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TripDetailsReadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TripDetailsReadDto>;
        }));
    }

    protected processTripsGET(response: HttpResponseBase): Observable<TripDetailsReadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = TripDetailsReadDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TripDetailsReadDto>(null as any);
    }

    /**
     * @return OK
     */
    tripsPUT(id: number, body: TripEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTripsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    tripsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Trips/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTripsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTripsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTripsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class CategoryCreateDto implements ICategoryCreateDto {
    name!: string;
    isDefault?: boolean;

    [key: string]: any;

    constructor(data?: ICategoryCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryCreateDto>(data, _mappings, CategoryCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : null as any;
        return data;
    }
}

export interface ICategoryCreateDto {
    name: string;
    isDefault?: boolean;

    [key: string]: any;
}

export class CategoryEditDto implements ICategoryEditDto {
    id!: number;
    name!: string;
    isDefault?: boolean;

    [key: string]: any;

    constructor(data?: ICategoryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryEditDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryEditDto>(data, _mappings, CategoryEditDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : null as any;
        return data;
    }
}

export interface ICategoryEditDto {
    id: number;
    name: string;
    isDefault?: boolean;

    [key: string]: any;
}

export class CategoryReadDto implements ICategoryReadDto {
    id?: number;
    name?: string;
    isDefault?: boolean;
    isArchived?: boolean;

    [key: string]: any;

    constructor(data?: ICategoryReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : null as any;
            this.isArchived = _data["isArchived"] !== undefined ? _data["isArchived"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryReadDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryReadDto>(data, _mappings, CategoryReadDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : null as any;
        data["isArchived"] = this.isArchived !== undefined ? this.isArchived : null as any;
        return data;
    }
}

export interface ICategoryReadDto {
    id?: number;
    name?: string;
    isDefault?: boolean;
    isArchived?: boolean;

    [key: string]: any;
}

export class ItemCreateDto implements IItemCreateDto {
    name!: string;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: IItemCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ItemCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ItemCreateDto>(data, _mappings, ItemCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : null as any;
        return data;
    }
}

export interface IItemCreateDto {
    name: string;
    categoryId: number;

    [key: string]: any;
}

export class ItemEditDto implements IItemEditDto {
    id!: number;
    name!: string;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: IItemEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ItemEditDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ItemEditDto>(data, _mappings, ItemEditDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : null as any;
        return data;
    }
}

export interface IItemEditDto {
    id: number;
    name: string;
    categoryId: number;

    [key: string]: any;
}

export class ItemReadDto implements IItemReadDto {
    id?: number;
    name?: string;
    categoryId?: number;
    categoryName?: string;
    isArchived?: boolean;

    [key: string]: any;

    constructor(data?: IItemReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : null as any;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : null as any;
            this.isArchived = _data["isArchived"] !== undefined ? _data["isArchived"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ItemReadDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ItemReadDto>(data, _mappings, ItemReadDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : null as any;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : null as any;
        data["isArchived"] = this.isArchived !== undefined ? this.isArchived : null as any;
        return data;
    }
}

export interface IItemReadDto {
    id?: number;
    name?: string;
    categoryId?: number;
    categoryName?: string;
    isArchived?: boolean;

    [key: string]: any;
}

export class LoginModel implements ILoginModel {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"] !== undefined ? _data["email"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginModel>(data, _mappings, LoginModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email !== undefined ? this.email : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        return data;
    }
}

export interface ILoginModel {
    email: string;
    password: string;

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;
    confirmPassword?: string;

    [key: string]: any;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"] !== undefined ? _data["email"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
            this.confirmPassword = _data["confirmPassword"] !== undefined ? _data["confirmPassword"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterRequest>(data, _mappings, RegisterRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email !== undefined ? this.email : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : null as any;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
    confirmPassword?: string;

    [key: string]: any;
}

export class TripCreateDto implements ITripCreateDto {
    startDate!: Date;
    endDate!: Date;
    destination!: string;
    categoryIds?: number[];

    [key: string]: any;

    constructor(data?: ITripCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : null as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : null as any;
            this.destination = _data["destination"] !== undefined ? _data["destination"] : null as any;
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            else {
                this.categoryIds = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TripCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripCreateDto>(data, _mappings, TripCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["startDate"] = this.startDate ? formatDate(this.startDate) : null as any;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : null as any;
        data["destination"] = this.destination !== undefined ? this.destination : null as any;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data;
    }
}

export interface ITripCreateDto {
    startDate: Date;
    endDate: Date;
    destination: string;
    categoryIds?: number[];

    [key: string]: any;
}

export class TripDetailsReadDto implements ITripDetailsReadDto {
    id?: number;
    destination?: string;
    startDate?: Date;
    endDate?: Date;
    items?: TripItemReadDto[];

    [key: string]: any;

    constructor(data?: ITripDetailsReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.destination = _data["destination"] !== undefined ? _data["destination"] : null as any;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : null as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : null as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TripItemReadDto.fromJS(item, _mappings)!);
            }
            else {
                this.items = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TripDetailsReadDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripDetailsReadDto>(data, _mappings, TripDetailsReadDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["destination"] = this.destination !== undefined ? this.destination : null as any;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : null as any;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : null as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface ITripDetailsReadDto {
    id?: number;
    destination?: string;
    startDate?: Date;
    endDate?: Date;
    items?: TripItemReadDto[];

    [key: string]: any;
}

export class TripEditDto implements ITripEditDto {
    id!: number;
    startDate!: Date;
    endDate!: Date;
    destination!: string;

    [key: string]: any;

    constructor(data?: ITripEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : null as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : null as any;
            this.destination = _data["destination"] !== undefined ? _data["destination"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TripEditDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripEditDto>(data, _mappings, TripEditDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : null as any;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : null as any;
        data["destination"] = this.destination !== undefined ? this.destination : null as any;
        return data;
    }
}

export interface ITripEditDto {
    id: number;
    startDate: Date;
    endDate: Date;
    destination: string;

    [key: string]: any;
}

export class TripItemCreateDto implements ITripItemCreateDto {
    itemId?: number;
    isPacked?: boolean;

    [key: string]: any;

    constructor(data?: ITripItemCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : null as any;
            this.isPacked = _data["isPacked"] !== undefined ? _data["isPacked"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TripItemCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripItemCreateDto>(data, _mappings, TripItemCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["itemId"] = this.itemId !== undefined ? this.itemId : null as any;
        data["isPacked"] = this.isPacked !== undefined ? this.isPacked : null as any;
        return data;
    }
}

export interface ITripItemCreateDto {
    itemId?: number;
    isPacked?: boolean;

    [key: string]: any;
}

export class TripItemEditDto implements ITripItemEditDto {
    id?: number;
    isPacked?: boolean;

    [key: string]: any;

    constructor(data?: ITripItemEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.isPacked = _data["isPacked"] !== undefined ? _data["isPacked"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TripItemEditDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripItemEditDto>(data, _mappings, TripItemEditDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["isPacked"] = this.isPacked !== undefined ? this.isPacked : null as any;
        return data;
    }
}

export interface ITripItemEditDto {
    id?: number;
    isPacked?: boolean;

    [key: string]: any;
}

export class TripItemReadDto implements ITripItemReadDto {
    tripItemId?: number;
    itemId?: number;
    itemName?: string;
    categoryId?: number;
    categoryName?: string;
    isPacked?: boolean;

    [key: string]: any;

    constructor(data?: ITripItemReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tripItemId = _data["tripItemId"] !== undefined ? _data["tripItemId"] : null as any;
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : null as any;
            this.itemName = _data["itemName"] !== undefined ? _data["itemName"] : null as any;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : null as any;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : null as any;
            this.isPacked = _data["isPacked"] !== undefined ? _data["isPacked"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TripItemReadDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripItemReadDto>(data, _mappings, TripItemReadDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tripItemId"] = this.tripItemId !== undefined ? this.tripItemId : null as any;
        data["itemId"] = this.itemId !== undefined ? this.itemId : null as any;
        data["itemName"] = this.itemName !== undefined ? this.itemName : null as any;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : null as any;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : null as any;
        data["isPacked"] = this.isPacked !== undefined ? this.isPacked : null as any;
        return data;
    }
}

export interface ITripItemReadDto {
    tripItemId?: number;
    itemId?: number;
    itemName?: string;
    categoryId?: number;
    categoryName?: string;
    isPacked?: boolean;

    [key: string]: any;
}

export class TripSummaryReadDto implements ITripSummaryReadDto {
    id?: number;
    destination?: string;
    startDate?: Date;
    endDate?: Date;
    totalItems?: number;
    packedItems?: number;

    [key: string]: any;

    constructor(data?: ITripSummaryReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.destination = _data["destination"] !== undefined ? _data["destination"] : null as any;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : null as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : null as any;
            this.totalItems = _data["totalItems"] !== undefined ? _data["totalItems"] : null as any;
            this.packedItems = _data["packedItems"] !== undefined ? _data["packedItems"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TripSummaryReadDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TripSummaryReadDto>(data, _mappings, TripSummaryReadDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["destination"] = this.destination !== undefined ? this.destination : null as any;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : null as any;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : null as any;
        data["totalItems"] = this.totalItems !== undefined ? this.totalItems : null as any;
        data["packedItems"] = this.packedItems !== undefined ? this.packedItems : null as any;
        return data;
    }
}

export interface ITripSummaryReadDto {
    id?: number;
    destination?: string;
    startDate?: Date;
    endDate?: Date;
    totalItems?: number;
    packedItems?: number;

    [key: string]: any;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}